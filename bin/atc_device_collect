#!/usr/bin/php
<?php

################################################################################
# Load Cisco Marking Configuration Values                                      #
################################################################################
if (($cisco_configs = parse_ini_file(getenv("CISCO_PATH") . "/config.ini", true)) === false)
{
  echo "\n\033[1;31;40mERROR: \033[0;37;40m Reading Cisco configuration file: " . getenv("CISCO_PATH") . "/config.ini\n";
  exit(1);
}

################################################################################
# Load the provided system_functions library                                   #
################################################################################
require_once("{$cisco_configs["lib_path"]}/system_functions.php");

################################################################################
# Include libraries to access a device via ssh(Swinburne ATC lab setup).       #
################################################################################
require_once("{$cisco_configs["lib_path"]}/consolessh.php");

################################################################################
# Include libraries to talk to and capture stuff from a device (password       #
# support is still crap                                                        #
################################################################################
$password = "cisco";

require_once("{$cisco_configs["lib_path"]}/devicecontrol.php");

################################################################################
#          >>>>>>>>>> FETCH DEVICE INFORMATION FUNCTIONS <<<<<<<<<<            #
################################################################################
# Servers to contact to download information about device allocation and access#
# information from for each room in the ATC building                           #
################################################################################
$atc_servers = array(8 => array("description" => "Cisco Devices in ATC328",
                                "url"         => "https://ictencsvr2.ict.swin.edu.au/agent/get_all.php",
                               ),

                     9 => array("description" => "Cisco Devices in ATC329",
                                "url"         => "https://ictencsvr6.ict.swin.edu.au/agent/get_all.php",
                               ),

                     0 => array("description" => "Cisco Devices in ATC330",
                                "url"         => "https://ictencsvr11.ict.swin.edu.au/agent/get_all.php",
                               )
                    );

################################################################################
# GetATCServerList()                                                           #
#                                                                              #
# Asks the user which rooms the lab exam is running in. The list of possible   #
# rooms is in the global $atc_servers variable. A dialog box with a checklist  #
# of rooms is displayed, allowing users the option of terminating the program. #
# We loop repeatedly until the user quits or selects at least one room. The    #
# selected rooms are returned in an array of indexes to the global $atc_servers#
# array                                                                        #
################################################################################
function GetATCServerList()
{
  global $exam_details, $atc_servers;

  foreach ($atc_servers as $key => $details) $items[$key] = $details["description"];

  while (true)
  {
    $choice = DisplayCheckList(" ATC Exam Room Selection ",
                               "Please select which rooms you would like to collect router configurations from",
                               $items,
                               $exam_details["Exam Details"]["name"],
                               '--cancel-label "Quit"'
                              );

    switch ($choice->code)
    {
      case 0:
        $selected = array_filter(explode(" ", $choice->output));
        array_walk($selected, create_function('&$val', '$val = trim($val, \'"\');'));
        if (count($selected) > 0) return $selected;

        DisplayMessage(" ATC Exam Room Selection ",
                       "ERROR: You must select at least one room to download device configurations from",
                       $exam_details["Exam Details"]["name"]
                      );
        break;
      default:
        if (DisplayYesNo(" Terminate Program ", 
                         "Are you sure that you want to terminate collection and marking now?",
                         $exam_details["Exam Details"]["name"]
                        ))
          exit(1);
    }
  }
}

################################################################################
# GetAuthDetails()                                                             #
#                                                                              #
# Asks user for their SIMS username and password. Allows user to terminate the #
# program. We loop repeatedly until the user quits or enters some details.     #
# Entered password is hashed out for privacy, entered details are returned as  #
# an array                                                                     #
################################################################################
function GetAuthDetails()
{
  global $exam_details;

  while (true)
  {
    exec('dialog --backtitle "' . $exam_details["Exam Details"]["name"] . '" \
                 --stdout --colors --insecure --cancel-label "Quit" \
                 --title " ATC Website Authentication Information " \
                 --mixedform "Enter Swinburne SIMS Details below:\n" 25 70 15 \
                             "Username:" 2 2 "" 2 15 50 50 0 \
                             "Password:" 4 2 "" 4 15 50 50 1',
         $output, $result);

    if ($result == 0) return array("username" => $output[0], "password" => $output[1]);

    if (DisplayYesNo(" Terminate Program ", 
                     "Are you sure that you want to terminate collection and marking now?",
                     $exam_details["Exam Details"]["name"]
                    )) 
      exit(1);
  }
}

################################################################################
# DelayCollection()                                                            #
#                                                                              #
# Wait for user to decide when to start marking exams. We loop repeatedly until#
# the user quits or decides to collect. Our waiting message will list all the  #
# students sitting the exam                                                    #
################################################################################
function DelayCollection()
{
  global $exam_details, $device_db;

  $collect_message = "Collecting for " . count($device_db) . " students.\n";
  foreach ($device_db as $student_id => $devices) $collect_message.= "  $student_id: " . implode(", ", array_keys($devices)) . "\n";

  while (true)
  {
    if (DisplayYesNo(" About to start collection ", 
                     "Do not continue until all students have completed the exam and you are ready to collect their configurations.\n\nStudents to collect configurations for:\n$collect_message",
                     $exam_details["Exam Details"]["name"],
                     '--ok-label "Collect" --no-label "Quit" '
                    )) 
      return;

    if (DisplayYesNo(" Terminate Program ", 
                     "Are you sure that you want to terminate collection and marking now?",
                     $exam_details["Exam Details"]["name"]
                    )) 
      exit(1);
  }
}

################################################################################
# FetchRoomDetails($url, $auth_details)                                        #
#                                                                              #
# Connects to the specified URL using the provided authentication details and  #
# attempts to download device details for the corresponding room. Possible     #
# outcomes are:                                                                #
#  - Error connecting to server, terminate program with error message          #
#  - No devices booked by user, return false                                   #
#  - Return content of response, list of pre-formatted device details          #
################################################################################
function FetchRoomDetails($url, $auth_details)
{
  global $exam_details;

  $httpquery = new HttpRequest();

  $httpquery->setURL($url);
  $httpquery->setMethod(HttpRequest::METH_POST);
  $httpquery->setPostFields($auth_details);
  $httpquery->send();
  if ($httpquery->getResponseCode() != 200)
  {
    DisplayMessage(" ERROR Accessing Site ", "Unable to connect to $url, this is a terminal problem", $exam_details["Exam Details"]["name"]);
    exit(1);
  }

  $result = $httpquery->getResponseData();
  if ($result["body"] == "Logon error\n")
  {
    DisplayMessage(" ERROR Authenticating ", "Bad username/password combination supplied");
    return false;
  }

  return $result["body"];
}

################################################################################
# DownloadDeviceDetails($server_list, $description)                            #
#                                                                              #
# Returns an array containing all the downloaded device details from the       #
# nominated ATC servers                                                        #
#  - Loop through each room we are collecting for                              #
#    o Attempt to fetch the details of devices/students for that room, this    #
#      function will terminate on a major error or return false if             #
#      authentication fails                                                    #
#    o While authentication fails, re-query the user for username/password     #
#    o Append the returned details to the return string                        #
#  - All OK, break the downloaded data into an array for the function response #
################################################################################
function DownloadDeviceDetails($server_list, $description)
{
  global $exam_details, $atc_servers, $auth_details;

  $device_list = "";

  $num_rooms = count($server_list);
  $room_count = 0;
  foreach ($server_list as $index) $download_status[$atc_servers[$index]["description"]] = 'Waiting';
  DisplayProgress("Fetching $description", round(100 * $room_count / $num_rooms), "Downloading student allocations...\n", $download_status, $exam_details["Exam Details"]["name"], '--no-collapse');

  foreach ($server_list as $index)
  {
    while (($details = FetchRoomDetails($atc_servers[$index]["url"], $auth_details)) === false)
    {
      $auth_details = GetAuthDetails();
      DisplayProgress("Fetching $description", round(100 * $room_count / $num_rooms), "Downloading student allocations...\n", $download_status, $exam_details["Exam Details"]["name"], '--no-collapse');
//      echo "\033[1;36;40mFetching $description for:\033[0;37;40m " . $atc_servers[$index]["description"] . "\n";
    }

    $room_count++;
    $download_status[$atc_servers[$index]["description"]] = 5;
    $device_list.= $details;

    DisplayProgress("Fetching $description", round(100 * $room_count / $num_rooms), "Downloading student allocations...\n", $download_status, $exam_details["Exam Details"]["name"], '--no-collapse');
//    echo "\033[1;36;40mFetching $description for:\033[0;37;40m " . $atc_servers[$index]["description"] . "\n";
  }
  return explode("\n", trim($device_list));
}

################################################################################
# FetchDeviceDB()                                                              #
#                                                                              #
# Fetch all device allocation information and return an associative array      #
# storing device information, how to ssh to it, who (which student) configured #
# it.                                                                          #
# - Call DownloadDeviceDetails() to get details on all devices in the rooms we #
#   are collecting from                                                        #
# - If something was returned:                                                 #
#   o Loop through each line of data                                           #
#     - Extract each field of information (in $data[])                         #
#     - $data[7] contains <student_id>_<device_name>                           #
#       o If empty, error, move onto next device                               #
#       o Split into student_id and device_name                                #
#       o If no data for device_name, set it to the whole field                #
#     - If we are not collecting for this device, don't add it to the array    #
#     - Create depth to the associative array if necessary                     #
#     - If we detect a duplicate device for the same student, abort collection #
#     - Populate the array with the extracted data                             #
#   o If the array is not empty (at least one student) return the generated    #
#     array                                                                    #
# - If we get here we have nothing to collect, report an error and terminate   #
################################################################################
function FetchDeviceDB()
{
  global $exam_details, $server_list;

  if (count($device_list = DownloadDeviceDetails($server_list, "device allocations")) > 0)
  {
    $device_db = array();

    foreach ($device_list as $data_line)
    {
      if (strlen($data_line) == 0) continue;
      $data = str_getcsv($data_line, ":");

      if (strlen($data[7]) == 0) continue;

      list($student_id, $device_name) = split("_", $data[7], 2);

      if ($device_name === "") $device_name = $data[7];

      if (!in_array($device_name, $exam_details["Exam Details"]["devices"])) continue;

      if (array_key_exists($student_id, $device_db) === false) $device_db[$student_id] = array();

      if (array_key_exists($device_name, $device_db[$student_id]) === true)
      {
        echo "\033[1;31;40mERROR:\033[0;37;40m Duplicate device name ($device_name) allocated to student ($student_id)\n";
        exit(1);
      }

      $device_db[$student_id][$device_name] = array("server" => $data[1],
                                                    "username" => $data[2],
                                                    "password" => $data[3],
                                                    "fullname" => $data[5],
                                                    "nickname" => $device_name
                                                   );
    }
    if (count($device_db) > 0) return $device_db;
  }

  echo "\033[1;31;40mERROR:\033[0;37;40m No devices to collect for\n";
  exit(1);
}

################################################################################
#                >>>>>>>>>> CHILD PROCESS FUNCTIONS <<<<<<<<<<                 #
################################################################################
# sig_child($signal)                                                           #
#                                                                              #
# Called whenever a child process dies, this can happen in three ways:         #
#  1) success                                                                  #
#  2) failure                                                                  #
#  3) termination                                                              #
#                                                                              #
# Wait for a particular process to cleanup (pcntl_wait()) in a loop (so we     #
# handle all dead processes in the handler (we return when no more terminated  #
# child processes exist. For each terminated child process ($pid):             #
# - Get the $student_id and $device_name allocated to that child process for   #
#   collection                                                                 #
# - If the process was killed, set the error_message data field in $device_db  #
#   for this device to reflect what happened                                   #
# - If the process terminated but returned failure, set the error_message data #
#   field in $device_db for this device to reflect what happened               #
# - Otherwise the collection worked OK, we:                                    #
#   - Remove the details for the specific device in $device_db so we don't try #
#     to capture it again                                                      #
#   - If no devices remain for the specific student_id in $device_db, remove   #
#     the details for this student so we don't think we have further devices   #
#     to capture for this student                                              #
# - In all cases, we remove the $pid from the list of child PIDs ($child_pid)  #
#   so we know how many (and which) processes are still executing              #
################################################################################
function sig_child($signal)
{
  global $device_db, $child_pids, $borked_pids;

  while(($pid = pcntl_wait($status, WNOHANG)) > 0)
  {
    $student_id  = $child_pids[$pid]["student_id"];
    $device_name = $child_pids[$pid]["device_name"];

    if (!pcntl_wifexited($status))
      $device_db[$student_id][$device_name]["error_message"] = "Collection process timed-out and was forcibly terminated";
    else if (pcntl_wexitstatus($status) > 0) 
    {
      $device_db[$student_id][$device_name]["error_message"] = "Collection process returned failure";
      $borked_pids++;
    } else
    {
//      echo " - Collected $device_name for $student_id\n";
      unset($child_pids[$pid]);
    }
  }
}

################################################################################
# Countdown_Delay($delay)                                                      #
#                                                                              #
# Print a countdown timer and return when finished. In each second (moderated  #
# by sleep(1)), dispatch waiting signals, this allows children to terminate    #
# properly                                                                     #
################################################################################
function Countdown_Delay($delay)
{
  global $exam_details, $child_pids, $borked_pids;

  $spinner = array(" \\", " |", " /", " -");

  $total_processes = count($child_pids);
  $progress_items["Number of devices:"] = $total_processes;
  $progress_items["Aborted collections:"] = "(None)";
  $progress_items["Countdown timer"] = "-100";

  //echo "\033[1;36;40mGiving collection processes $delay seconds to complete their job\033[0;37;40m\n    ";
  //echo "Borked  To_Collect  Countdown\n";
  for ($count = $delay; $count > 0; $count--)
  {
    if ($borked_pids > 0) $progress_items["Aborted collections:"] = "($borked_pids)";
    $progress_items["Countdown timer"] = "-" . round(100 - (100 * $count / $delay));
    $collected_progress = 100 - (100 * count($child_pids) / $total_processes);

    DisplayProgress("Collecting Output", $collected_progress, "Collecting from devices", $progress_items, $exam_details["Exam Details"]["name"]);

    // Terminate loop early if there are no more child processes running
    if (count($child_pids) === 0) return;

    // Terminate loop early if the remaining child processes are all borked
    if ($borked_pids === count($child_pids)) return;

    sleep(1);

    pcntl_signal_dispatch();
  }
  //echo "\n";
}

################################################################################
# TerminateChildren($child_pids)                                               #
#                                                                              #
# Terminate all children in the provided list of processes (and wait for the   #
# process to actually die                                                      #
################################################################################
function TerminateChildren($child_pids)
{
  global $exam_details;

//  echo "Terminating stuck collection processes";
  $total_count = count($child_pids);
  $progress_count = 0;
  foreach ($child_pids as $pid => $device_details)
  {
    if (posix_kill($pid, 0))
    {
      DisplayProgress("Terminating Stuck Collection Processes", 100 * $progress_count / $total_count, "Killing process $pid...\n", array(), $exam_details["Exam Details"]["name"]);

      posix_kill($pid, SIGINT);
    }
    pcntl_waitpid($pid, $status);
  }
}

################################################################################
# ChildProcess_CollectDevice($group_name, $student_id, $device_name,           #
#                            $interactive)                                     #
#                                                                              #
# This function collects the output of executing all commands for the specified#
# device for the specified student and saves the captured text in files in the #
# correct location.                                                            #
#                                                                              #
# - Figure out location of capture files, based on test name, group name,      #
#   student ID and device name                                                 #
# - Connect to the device and try to go to enable mode. If we fail, terminate  #
#   with failure.  The main loop will retry later on                           #
#   o For interactive mode, we return failure                                  #
#   o For parallel processing, this is a child process, we exit the process    #
#     with failure                                                             #
# - We are now in enable mode                                                  #
# - For each command we want to capture                                        #
#   - Capture the output of the command, if the command is in the array        #
#     $strip_bangs_commands, then ask DeviceControl() to strip the extra       #
#     exclamation marks before returning                                       #
#   - Write the captured text to an output file named for the captured command #
# - Depending on the device type, clear all settings so it can be safely       #
#   rebooted                                                                   #
# - Return the default success code                                            #
#   o For parallel processing, this is a child process, we exit the process    #
################################################################################
function ChildProcess_CollectDevice($group_name, $student_id, $device_name, $parallel)
{
  global $device_db, $cisco_configs, $exam_details;

  $strip_bangs_commands = array("show run", "sh run", "sho run");
  $return_code = 0;

  // No output if in parallel processing
  if ($parallel) ob_start();

  // Create classes to connect and talk to the devices
  $ssh = new ConsoleSSH();
  $console = new DeviceControl($ssh);

  // Get output directory for captured files for this device
  $collect_dir = CollectBaseDir($cisco_configs, $exam_details) . "/$group_name/$student_id/$device_name/";

  while (!file_exists($collect_dir)) mkdir($collect_dir, 0777, $recursive=TRUE);

  // Connect to the device and go to enable mode. If unsuccessful, terminate with failure
  if (($ssh->Connect($device_db[$student_id][$device_name])) === false) { $return_code = 1; goto terminate; };
  if ($console->GoEnable(!$parallel) === false) { $return_code = 1; goto terminate; }

  // In enable mode, run each command one at a time
  foreach ($exam_details[$device_name]["commands"] as $index => $command)
  {
    // Remove bogus exclamation marks if the nominated command matches our list
    switch ($exam_details[$device_name]["type"])
    {
      case "A": $device_output = $console->CaptureCommandASA($command, in_array($command, $strip_bangs_commands)); break;
      default:  $device_output = $console->CaptureCommand($command, in_array($command, $strip_bangs_commands)); break;
    }

    // Create output file for command and save collected content
    $fout = fopen($collect_dir . str_replace("/", "_", str_replace("|", "-", str_replace(" ", "_", $command))), "w+");
    fwrite($fout, $device_output);
    fclose($fout);
  }

  // Finished with device, call appropriate device clean-up function
  switch ($exam_details[$device_name]["type"])
  {
    case "R": $console->EraseRouter(); break;
    case "S": $console->EraseSwitch(); break;
    case "A": $console->EraseASA(); break;
    default:  echo "  Unknown device type - not cleaning\n";
  }

terminate:
  // Parallel processing, turn output back on, kill process (this is a child)
  if ($parallel)
  {
    sleep(5);
    $ssh->Disconnect();
    sleep(1);
    ob_end_clean();
    exit($return_code);
  }

  return $return_code;
}

################################################################################
#                 >>>>>>>>>> MAIN PROCESS FUNCTIONS <<<<<<<<<<                 #
################################################################################
# CollectDevices($group_name)                                                  #
#                                                                              #
# This function collects the output of executing all commands specified in     #
# $exam_details(global) for all devices/students configured in $device_db      #
# (global) and writes output files based on the provided class/group name      #
# ($group_name)                                                                #
#                                                                              #
# Loop through each student that we have allocated devices to.                 #
# - Loop through each device name we are collecting for                        #
#   - Bypass if device doesn't exist for this student, we already collected on #
#     a previous pass                                                          #
#     - If we are parallel processing:                                         #
#       - Fork a child process and call ChildProcess_CollectDevice() to collect#
#         everything for this student/device. This function always terminates  #
#         the child process so all continuing code is the parent process       #
#       - Store the child process PID as well as the student id and device     #
#         name allocated to this child process to collect                      #
#     - If sequential (interactive) processing:                                #
#       - Call ChildProcess_CollectDevice() to collect everything for this     #
#         student/device                                                       #
#       - If collection failed, store the student_id and device name in        #
#         $child_pids for later processing                                     #
#                                                                              #
# If we are parallel processing:                                               #
# - Sleep the parent process for a delay period to give the collection child   #
#   processes a chance to successfully terminate.                              #
# - If any child processes are still running ($child_pids), forcibly terminate #
#   them                                                                       #
#                                                                              #
# $child_pids contains a list of all devices we failed to collect from         #
# - Rebuild $device_db with only the contents for devices listed in $child_pids#
# - If $device_db is non-empty, return false to indicate a failure to collect  #
################################################################################
function CollectDevices($group_name, $parallel)
{
  global $device_db, $exam_details, $child_pids, $borked_pids;

  //if ($parallel) echo "\033[1;36;40mLaunching child processes to collect data from devices...\033[0;37;40m\n";

  $pid = 0;
  $borked_pids = 0;
  $child_pids = array();

  // Loop through students in turn
  //foreach ($device_db as $student_id => $devices)
  foreach ($exam_details["Exam Details"]["devices"] as $device_name)
  {
    if (!$parallel) echo "\033[1;36;40mCollecting for student ($student_id)...\033[0;37;40m\n";

    // Devices in order
    //foreach ($exam_details["Exam Details"]["devices"] as $device_name)
    foreach ($device_db as $student_id => $devices)
    {
      if (array_key_exists($device_name, $devices) === false) continue;

      if ($parallel)
      {
        // Parallel processing, launch a child process to capture output from
        // the device. This process will terminate when completed
        if (($pid = pcntl_fork()) == 0) ChildProcess_CollectDevice($group_name, $student_id, $device_name, $parallel);

        // Store the process ID so we know which devices were collected by which processes
        $child_pids[$pid]["student_id"] = $student_id;
        $child_pids[$pid]["device_name"] = $device_name;
      } else
      {
        if (ChildProcess_CollectDevice($group_name, $student_id, $device_name, $parallel) === 1)
        {
          // $pid is monotonically increasing for each collection that failed
          $child_pids[++$pid]["student_id"] = $student_id;
          $child_pids[$pid]["device_name"] = $device_name;
        }
      }
    }
    usleep(200000);
  }

  if ($parallel)
  {
    // Parallel processing, need to do some cleanup
    //echo "  " . count($child_pids) . " child processes launched\n";

    // Give collection processes a chance to succeed
    Countdown_Delay($exam_details["Collect"]["timeout_delay"]);
    //echo "\n";

    // $child_pids contains list of processes we need to terminate
    if (count($child_pids) > 0) TerminateChildren($child_pids);
  }

  // Use list of $child_pids to build a new, cut-down version of $device_db
  $fail_list = array();
  foreach ($child_pids as $pid => $details)
  {
    $student_id = $details["student_id"];
    $device_name = $details["device_name"];
    $fail_list[$student_id][$device_name] = $device_db[$student_id][$device_name];
    $fail_list[$student_id][$device_name]["error_message"] = "Collection process was forcibly terminated";
    unset($child_pids[$pid]);
  }
  $device_db = $fail_list;

  // If there is still something in $device_db, we failed and need to try again
  if (count($device_db) > 0) return false;
}

################################################################################
# MAIN PROGRAM                                                                 #
################################################################################
# Parse command line parameters                                                #
################################################################################
// Check command line parameters
if (count($argv) != 3)
{
  echo "Usage: $argv[0] <exam_config_file> <group_name>\n";
  echo "
  <exam_config_file> : Configuration file detailing what to collect from what
  <group_name>       : Name of group to store configurations under\n";
  exit(1);
}

// Get exam configuration details
if (($exam_details = parse_ini_file($argv[1], true)) === false)
{
  echo "\n\033[1;31;40mERROR: \033[0;37;40m Reading exam_config_file ({$argv[1]})\n";
  exit(1);
}

// Get the group name
$group_name = $argv[2];

// Make sure the exam is configured to collect from the ATC Labs
if ($exam_details["Collect"]["data_source"] != "atc")
{
  echo "\033[1;31;40mERROR:\033[0;37;40m Exam configuration file not configured for collection in atc building (hint: variable \'data_source\' in section \'Collect'\)\n";
  exit(1);
}

// Get room information and authentication information from the user
$server_list = GetATCServerList();
$auth_details = GetAuthDetails();

// Download device details and student allocations from ATC web server
$device_db = FetchDeviceDB();

// Wait for exam to finish and prompt to start collection
DelayCollection();

// How are we collecting, sequentially or in parallel
$parallel = $exam_details["Collect"]["parallel"];
if (!$parallel) echo "\033[1;36;40mCollection Style:\033[0;37;40m Interactive\n";

// Install signal handler to handle when a child(collection process dies)
pcntl_signal(SIGCHLD, "sig_child");

// Collect everything
while (CollectDevices($group_name, $parallel) === false)
{
  $message = "------------------------------------------------------------------------------------------------------\n";
  $message.= "Student #\tDevice Details\n";
  $message.= "------------------------------------------------------------------------------------------------------\n";
  foreach ($device_db as $student_id => $devices)
    foreach ($devices as $device_name => $details)
      $message.= "$student_id\t" . $details["fullname"] . "($device_name)\t" . $details["error_message"] . "\n";
  $message.= "------------------------------------------------------------------------------------------------------\n\n";
  $message.= "Please try to repair these configurations, and then select whether we should try to collect them again\n";
  if (!DisplayYesNo("Failed to collect configs for the following devices", 
                    $message,
                    $exam_details["Exam Details"]["name"]
                   ))      
    exit(1);
}

?>
